# Topics in Functional Programming Assignment 1

**Name:** Jack Joseph Gilbride
**Student Number:** 17340868

**A short document (text or PDF) outlining the design choices you made, and indicating how many of the project deliverables were satisfactorily completed. Include also a short (about a paragraph) reflection on the process of designing the DSL; some questions you might address include: did you find the design choices you had to make challenging? At any point did you have to revise your language design? How well did your choices fit with the needs to the rendering library chosen, and how might they have changed if the final rendering target was instead an SVG produced by Blaze?**

I used the Shapes.hs file from week 5 as a basis for my DSL. I liked it as a DSL because it was intuitive. All shapes could be instantiated using just a word, which gave a shape with a measurement of 1 unit centered on the origin. Measurements and coordinates did not need to be provided, instead shapes could undergo one or more translations to get them to the appropriate form. I wanted to keep the approach for the other shapes. However I also wanted to give the user flexibility in determining the initial "shape" of their rectangle or ellipse. To strike an approach somewhere in the middle, I let the user input the aspect ratio of the shape. The rectangle/ellipse is centered on the origin with height 1, like the other shapes, and its width is determined by the aspect ratio. The requirement for the polygon was that it was determined by a closed set of points, so I wanted this functionality *exactly* to be available to the user. The user simply lists the points after the word convexPolygon to create the appropriate polygon. Some convention had to be established so that these points were not completely arbitrary, so I chose to specify them as points going around the shape in a clockwise direction. When it came to actually implementing the polygon, I used the "halfLine" measure mentioned in class, which lined up nicely with the DSL representation of a list of points.

I initially found adding colors quite challenging and was confused on how best to implement them. I knew that I wanted color to be a datatype, but wasn't sure how to pair a color with a shape. Firstly I tried adding a color as an attribute of each shape, but this would have gotten messy and meant pattenr matching each individual shape in each function which only matches a generic shape. In the end I decided to add color each (transformation, shape) pair in the drawing, so each now became a triple. As the user already used a list of tuples to draw the drawing I felt that it this approach to color would be intuitive for them; each tuple is a shape, undergoing a specific transformation, filled by a specific color. Colors thus became datatypes with functions to hide their full implementation from the DSL, in the same way as transformations and shapes. It was important to me that colors could be invoked in a similar way to transformations and shapes as they were part of the same triple - hence the simple one word functions like "red", "blue" and "green" which the user can have at the end of their triple. I originally represented the rgba values in each color with a Double, but later converted these to Word8s, which led to better integration with JuicyPixels. This simplified the code but had no impact on the DSL as the user does not see this level of detail.

I originally wanted the mask operation to be an infix function like transformation composition, which would take two drawings. Later I wanted the user to be able to specificy the transparency of the masking image; I ultimately felt that this flexibility was more important to the language than having an infix funciton, so just made sure to give the function an intuitive name; "mask". Masking two drawings to give a new one is important because the user already has an understanding of what a drawing is in the DSL so they can work with the result; e.g. rendering the result or masking it with another drawing.

The design choices fit quite well with JuicyPixels due to the design improvements made in the original week 5 assignment. I also made particular decisions (e.g. storing rgba values as Word8s) to make rendering any additions to the program as seamless as possible. Some work would need to be done to the Shapes to get them to be convertable to SVGs. The "list of vectors" approach of the convexPolygon would lend itself well to it, and it would make sense to represent the other shapes in this form internally, while hopefully keeping the DSL the same.

There are some aspects of the DSL which are not immediately intuitive to the user. This is down to the wider design of the DSL and changing these would propagate changes through the functionality. These include:
- Having to pass coordinates using the `point` keyword - passing a tuple may be more intuitive
- Having to surround each negative number with brackets due to Haskell's representation of `-`
- The disparity between most shapes being of unit size at the origin while convexPoly is determined by points, meaning it can be at any place at any size
I do not feel that these issues are major and I feel like the user would become comfortable with them soon, and that otherwise the representation of Drawing as a list of triples strikes a good balance between intuitive, minimal and flexible.
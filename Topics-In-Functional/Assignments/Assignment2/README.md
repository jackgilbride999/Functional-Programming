# CSU44012 Assignment 2 - Minesweeper

*Include suitable comments wherever there is a part of the program that deserves greater explanation. Include a short document (text or PDF), about 2-3 pages will suffice, outlining the high level design choices you made, indicating how many of the project deliverables were satisfactorily completed. This should also include also a short (one or two paragraphs paragraph) reflection on the process of designing the program. Some questions you might consider here include: how suitable was Haskell as a language for tackling each phase of the project, what was your experience of the software development process (including things like testing and debugging), and what features of the language proved useful*

## Design Choices

### Board
The first phase of designing the program was designing the underlying representation of the board. The board would have multiple properties, which would need to be passed between functions throughout the program, so it made sense to create a *Board* data type to encapsulate them. In the end, the *Board* contained the cell numbers, cell statuses, board width, board height, number of mines and state of the game. This data would have been unmaintainable to pass throughout the program seperately, so it was a good decision to create this data type. I soon discovered that I would be querying the individual properties of the Board quite often, so I converted it to a record type. This was massively beneficial, as there were many instances where I quickly queried the board using record notation (`cells board`, `width board`, `height board` etc). It had the added benefit of cleaning up the code where a board was "updated". The underlying Haskell representation created a new Board with most of the properties of the old board, but the shorthand to do this (e.g. `board {cells = newCells}`) made this creation much shorter and reduced unnecessary restatement of properties that risk confusing the reader. On top of this, naming the properties makes it much cleaner what is going on when the board is initially created, so the benefit of the record type here is threefold.

The most obvious representation of the cells of the board was some sort of 2D structure. I felt that this would make indexing into the cells via some coordinates *(x, y)* much easier, and since the intuitive way to identify a cell from another part of the program was *(x, y)*, this was the way to go. At first I thought of creating a 2D list structure, but quickly realised that this would involve a lot of list iteration, splitting and re-concatenation. This seemed quite inefficient, and quite difficult syntactically. I decided instead to represent it using *Vectors*. Described on [haskell.hackage.org](https://hackage.haskell.org/package/vector) as "an efficient implementation of Int-indexed arrays", they seemed to perfectly suit the problem. Indeed they did and accessing them was quite intuitive, much like an array in other languages.

On top of the *Board* data type, I also created some simple data types for *CellStatus* and *GameState* as these were commonly accessed properties that needed some intuitive type representation. Once each of the data types were created, much of the functionality to access the *Board* was relatively intuitive. For each function I decided the function type first, this made the actual implementation easier as it guided me better about what the function should do. I tried to keep functions under five lines long where possible to aid readability, using helper functions where necessary.

### UI
The next step was to design the UI for the program. I had some experience with ThreePenny from the Week 11 assignment so used that as a starting point. I decided to use *IORefs* to monitor the state of the program due to my experience with them in Week 11. 

I wanted my game to be flexible with parameters, so provided three different difficulties to the user - "Beginner", "Intermediate" and "Expert". These are in line with the difficulties in the classic Windows Minesweeper game. The user is presented with one button for each difficulty. Once a button is selected, the appropriate *Board* is generated and the appropriate *Canvas* is drawn. 

The *Canvas* seemed like the obvious choice for the board as it was quite flexible, and we were provided with good examples of its usage already. 

The two main options available to the user are to change the game mode or to update the canvas. When the canvas is selected, it takes the mode into consideration. The user may be uncovering cells, flagging cells, or marking them with a question mark. Selecting a cell generates a *Board* with the appropriate cell status updated.

Initially I wanted to only redraw the clicked cell, but as cell updates can propagate outwards and affect more than one cell, I decided to redraw the canvas on each click. This did not noticably affect the performance of the program. Redrawing the canvas sets a background, draws lines at the boarder of each row / column, then fills each cell depending on its *cellStatus*. If the cell is *Visible*, then the number of adjacent mines is shown. Each number is a different color. The colors chosen mimic those in the classic Windows Minesweeper game.

All UI work was done in the UI monad. This was incredibly helpful as it forced the sequence of operations that needed to be sequenced (e.g. update the board, then query it, then draw the canvas). Another operation for which sequencing was important was reading and writing *IORefs*. Using them in the UI monad forced the use of `liftIO` quite a lot, but the use of `$` meant that these operations were not too clunky.

### AutoPlayer
I wanted to ensure that the auto player was as independent as possible, so only one function, `autoPlayerMove :: Board -> IO Board` is exposed to the main program. Pressing the autoplayer button in the UI calls this to update the board, then draws the canvas as normal. 

Firstly I wrote a function to uncover a cell completely at random. I wanted to start from here as my base, and knew that it would always be the last resort for the auto player when no other moves are available. 

Secondly I looked at the (Minesweeper wiki)[http://www.minesweeper.info/wiki/Strategy] for basic strategies that the auto player could employ. The first basic strategy was that if a cell was adjacent to the same number of hidden cells as its internal value, then each of those cells are mines. I created a function to do this to one cell. If there were multiple adjacent cells fitting this description, then the function would just flag the first. This way it can flag them one by one on each invocation. I wrapped this in a function to iterate over each cell in the board, and stop once one of these cells was successful.

